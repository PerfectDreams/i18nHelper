package net.perfectdreams.i18nhelper.plugin

import com.ibm.icu.text.MessagePatternUtil
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.kotlin.dsl.create
import org.yaml.snakeyaml.Yaml
import java.io.File

class I18nHelperPlugin : Plugin<Project> {
    companion object {
        private val yaml = Yaml()
        private const val TASK_NAME = "generateI18nKeys"
    }

    override fun apply(target: Project) {
        with(target) {
            val extension = project.extensions.create<I18nHelperPluginExtension>("i18nHelper")

            tasks.register(TASK_NAME) {
                // HACKY WORKAROUND!!!
                // This makes the generateI18nKeys task to always be ran after the compileKotlin step
                // We need to do this (instead of using withType) because, for some reason, it doesn't work and the task isn't executed.
                project.tasks.filter { it.name.startsWith("compileKotlin") }.forEach {
                    it.dependsOn(TASK_NAME)
                }

                doLast {
                    val localeFolder = File(this.project.buildDir, "generated/languages")
                    localeFolder.deleteRecursively()
                    localeFolder.mkdirs()

                    val map = mutableMapOf<String, Any>()

                    File(this.project.projectDir, extension.languageSourceFolder.get())
                        .listFiles()
                        .filter { it.nameWithoutExtension != "language" }
                        .forEach {
                            map += yaml.load<Map<String, Any>>(
                                it.readText()
                            )
                        }

                    val i18nKeysFile = FileSpec.builder(extension.generatedPackage.get(), "I18nKeys")
                    i18nKeysFile.addComment("Auto-generated by the \"$TASK_NAME\" Gradle task, do not modify this manually!\nhttps://github.com/PerfectDreams/i18nHelper\ni18n means \"Internationalization\"")

                    i18nKeysFile.addType(
                        addI18nKeys(
                            "I18nKeys",
                            "",
                            map
                        )
                    )

                    val i18nDataFile = FileSpec.builder(extension.generatedPackage.get(), "I18nKeysData")
                    i18nDataFile.addComment("Auto-generated by the \"$TASK_NAME\" Gradle task, do not modify this manually!\nhttps://github.com/PerfectDreams/i18nHelper\ni18n means \"Internationalization\"")

                    i18nDataFile.addType(
                        addI18nKeysData(
                            extension.generatedPackage.get(),
                            listOf(),
                            "I18nKeysData",
                            "",
                            map
                        )
                    )

                    i18nKeysFile.build().writeTo(localeFolder)
                    i18nDataFile.build().writeTo(localeFolder)
                }
            }
        }
    }

    fun addI18nKeys(firstChild: String, prefix: String, currentKey: Map<String, Any>): TypeSpec {
        val obj = TypeSpec.objectBuilder(firstChild.capitalize())

        for ((key, value) in currentKey) {
            if (value is Map<*, *>) {
                obj.addType(
                    addI18nKeys(
                        key,
                        "$prefix$key.",
                        value as Map<String, Any>
                    )
                )
            } else if (value is List<*>) {
                obj.addProperty(
                    PropertySpec.builder(
                        key.capitalize(),
                        ClassName("net.perfectdreams.i18nhelper.core.keys", "ListI18nKey")
                    )
                        .initializer("ListI18nKey(\"$prefix$key\")")
                        .build()
                )
            } else {
                obj.addProperty(
                    PropertySpec.builder(
                        key.capitalize(),
                        ClassName("net.perfectdreams.i18nhelper.core.keys", "StringI18nKey")
                    )
                        .initializer("StringI18nKey(\"$prefix$key\")")
                        .build()
                )
            }
        }

        return obj.build()
    }

    fun addI18nKeysData(classPackage: String, children: List<String>, firstChild: String, prefix: String, currentKey: Map<String, Any>): TypeSpec {
        val obj = TypeSpec.objectBuilder(firstChild.capitalize())

        for ((key, value) in currentKey) {
            if (value is Map<*, *>) {
                obj.addType(
                    addI18nKeysData(
                        classPackage,
                        children.toMutableList()
                            .apply {
                                this.add(key.capitalize())
                            },
                        key,
                        "$prefix$key.",
                        value as Map<String, Any>
                    )
                )
            } else if (value is List<*>) {
                obj.addType(
                    convertToKotlinPropertyOrMethod(classPackage, children, "ListI18nData", key, value.joinToString("\n")) // We will join the list into a single string, to make it easier to process them
                )
            } else {
                obj.addType(
                    convertToKotlinPropertyOrMethod(classPackage, children, "StringI18nData", key, value as String)
                )
            }
        }

        return obj.build()
    }

    private fun convertToKotlinPropertyOrMethod(classPackage: String, children: List<String>, classKeyToBeUsed: String, key: String, value: String): TypeSpec {
        val node = MessagePatternUtil.buildMessageNode(value)
        val hasAnyArgument = node.contents.any { it is MessagePatternUtil.ArgNode }

        val classBuilder = if (hasAnyArgument) {
            TypeSpec.classBuilder(key.capitalize())
        } else {
            TypeSpec.objectBuilder(key.capitalize())
        }

        val arguments = mutableListOf<String>()

        if (hasAnyArgument) {
            val constructor = FunSpec.constructorBuilder()

            node.contents.forEach {
                if (it is MessagePatternUtil.ArgNode) {
                    when (it.typeName) {
                        "integer" -> constructor.addParameter(it.name, Int::class)
                        "short" -> constructor.addParameter(it.name, Short::class)
                        "long" -> constructor.addParameter(it.name, Long::class)
                        else -> constructor.addParameter(it.name, Any::class)
                    }

                    arguments.add(it.name)
                }
            }

            classBuilder.primaryConstructor(constructor.build())
        }

        return classBuilder
            .addSuperclassConstructorParameter(
                CodeBlock.builder()
                    .add("${classPackage}.I18nKeys.${
                        children.toMutableList().apply {
                            this.add(key.capitalize())
                        }.joinToString(".")
                    }")
                    .add(", ")
                    .add("mutableMapOf(")
                    .apply {
                        for (argument in arguments) {
                            add("%S to $argument,", argument)
                        }
                    }
                    .add(")")
                    .build()
            )
            .superclass(
                ClassName(
                    "net.perfectdreams.i18nhelper.core.keydata",
                    classKeyToBeUsed
                )
            )
            .build()
    }
}